rtest.spearman <- r.test(
n = nrow(component_1),
n2 = nrow(component_2),
r12 = cor.c1.spearman,
r34 = cor.c2.spearman)
rtest.pearson <- r.test(
n = nrow(component_1),
n2 = nrow(component_2),
r12 = cor.c1.pearson,
r34 = cor.c2.pearson)
wtest <-wilcox.test(mse.c1, mse.c2)
#list with all information of interest
results[[l]] <- data.table(
discount_1 = disc1,
discount_2 = disc2,
nblock_1 = nblo1,
nblock_2 = nblo2,
type_1 = type1,
type_2 = type2,
spearman_1 = cor.c1.spearman,
spearman_2 = cor.c2.spearman,
pearson_1 = cor.c1.pearson,
pearson_2 = cor.c2.pearson,
mse_1 = mse.c1,
mse_2 = mse.c2,
p.spearman = round(rtest.spearman$p, 4),
z.spearman = round(rtest.spearman$z, 4),
p.pearson = round(rtest.pearson$p, 4),
z.pearson = round(rtest.pearson$z, 4),
p.mse = round(wtest$p.value, 4),
w.mse = round(wtest$statistic, 4)
)
l = l + 1
}
#convert results into data.table
results <- rbindlist(results)
results
#dataframe with all possible combinations
combinations <- expand.grid(
disc1 = c(0, 8),
disc2 = c(0, 8),
nblo1 = c(30, 100),
nblo2 = c(30, 100),
type1 = 1:6,
type2 = 1:6)
#dataframe with all combinations of interest
combinations <- subset(
combinations,
disc1 != disc2 &
nblo1 == nblo2 &
type1 == type2 |
disc1 == disc2 &
nblo1 != nblo2 &
type1 == type2 |
disc1 == disc2 &
nblo1 == nblo2 &
type1 != type2,
drop = TRUE)
results <- list()
l = 1
for (i in 1:nrow(combinations)) {
#filter every row separatly and subset values
row <- combinations[i,]
disc1 <- as.double(row["disc1"])
disc2 <- as.double(row["disc2"])
nblo1 <- as.double(row["nblo1"])
nblo2 <- as.double(row["nblo2"])
type1 <- as.double(row["type1"])
type2 <- as.double(row["type2"])
#make components for rtest
component_1 <- data.w[
discount == disc1 &
nblock == nblo1 &
type == type1]
component_2 <- data.w[
discount == disc2 &
nblock == nblo2 &
type == type2]
#spearman and pearson correlations
cor.c1.spearman <- cor(
component_1$par_tau,
component_1$true_par_tau,
method = "spearman")
cor.c2.spearman <- cor(
component_2$par_tau,
component_2$true_par_tau,
method = "spearman")
cor.c1.pearson <- cor(
component_1$par_tau,
component_1$true_par_tau,
method = "pearson")
cor.c2.pearson <- cor(
component_2$par_tau,
component_2$true_par_tau,
method = "pearson")
#correlation tests for spearman and pearson
rtest.spearman <- r.test(
n = nrow(component_1),
n2 = nrow(component_2),
r12 = cor.c1.spearman,
r34 = cor.c2.spearman)
rtest.pearson <- r.test(
n = nrow(component_1),
n2 = nrow(component_2),
r12 = cor.c1.pearson,
r34 = cor.c2.pearson)
#list with all information of interest
results[[l]] <- data.table(
discount_1 = disc1,
discount_2 = disc2,
nblock_1 = nblo1,
nblock_2 = nblo2,
type_1 = type1,
type_2 = type2,
spearman_1 = cor.c1.spearman,
spearman_2 = cor.c2.spearman,
pearson_1 = cor.c1.pearson,
pearson_2 = cor.c2.pearson,
mse_1 = mse.c1,
mse_2 = mse.c2,
p.spearman = round(rtest.spearman$p, 4),
z.spearman = round(rtest.spearman$z, 4),
p.pearson = round(rtest.pearson$p, 4),
z.pearson = round(rtest.pearson$z, 4)
)
l = l + 1
}
#convert results into data.table
results <- rbindlist(results)
results
#dataframe with all possible combinations
combinations <- expand.grid(
disc1 = c(0, 8),
disc2 = c(0, 8),
nblo1 = c(30, 100),
nblo2 = c(30, 100),
type1 = 1:6,
type2 = 1:6)
#dataframe with all combinations of interest
combinations <- subset(
combinations,
disc1 != disc2 &
nblo1 == nblo2 &
type1 == type2 |
disc1 == disc2 &
nblo1 != nblo2 &
type1 == type2 |
disc1 == disc2 &
nblo1 == nblo2 &
type1 != type2,
drop = TRUE)
results <- list()
l = 1
for (i in 1:nrow(combinations)) {
#filter every row separatly and subset values
row <- combinations[i,]
disc1 <- as.double(row["disc1"])
disc2 <- as.double(row["disc2"])
nblo1 <- as.double(row["nblo1"])
nblo2 <- as.double(row["nblo2"])
type1 <- as.double(row["type1"])
type2 <- as.double(row["type2"])
#make components for rtest
component_1 <- data.w[
discount == disc1 &
nblock == nblo1 &
type == type1]
component_2 <- data.w[
discount == disc2 &
nblock == nblo2 &
type == type2]
#spearman and pearson correlations
cor.c1.spearman <- cor(
component_1$par_tau,
component_1$true_par_tau,
method = "spearman")
cor.c2.spearman <- cor(
component_2$par_tau,
component_2$true_par_tau,
method = "spearman")
cor.c1.pearson <- cor(
component_1$par_tau,
component_1$true_par_tau,
method = "pearson")
cor.c2.pearson <- cor(
component_2$par_tau,
component_2$true_par_tau,
method = "pearson")
#correlation tests for spearman and pearson
rtest.spearman <- r.test(
n = nrow(component_1),
n2 = nrow(component_2),
r12 = cor.c1.spearman,
r34 = cor.c2.spearman)
rtest.pearson <- r.test(
n = nrow(component_1),
n2 = nrow(component_2),
r12 = cor.c1.pearson,
r34 = cor.c2.pearson)
#list with all information of interest
results[[l]] <- data.table(
discount_1 = disc1,
discount_2 = disc2,
nblock_1 = nblo1,
nblock_2 = nblo2,
type_1 = type1,
type_2 = type2,
spearman_1 = cor.c1.spearman,
spearman_2 = cor.c2.spearman,
pearson_1 = cor.c1.pearson,
pearson_2 = cor.c2.pearson,
p.spearman = round(rtest.spearman$p, 4),
z.spearman = round(rtest.spearman$z, 4),
p.pearson = round(rtest.pearson$p, 4),
z.pearson = round(rtest.pearson$z, 4)
)
l = l + 1
}
#convert results into data.table
results <- rbindlist(results)
results
df <- data.frame(
x = c(NA, NA, NA, 1, 6, 3, NA, 2),
y = c(1, 2, 9, NA, NA, NA, NA, 1),
z = c("a", "a", "a", "b", "b", "b", "c", "c")
)
rowSums(df[,c("x", "y")], na.rm = TRUE)
pkgs <- c(
"tidyverse",
"data.table",
)
pkgs <- c(
"tidyverse",
"data.table"
)
lapply(pkgs, library, character.only = TRUE)
# Input -------------------------------------------------------------------
install.packages("statsr")
sum(dbinom(0:3, size = 100, p= 0.5))
options(digits = 2)
sum(dbinom(0:3, size = 100, p= 0.5))
1 - sum(dbinom(0:3, size = 100, p= 0.5))
pbinom(3, 100, 0.5)
pbinom(3, 12, 0.5)
1 - pbinom(998, 6000, p = 1/6)
1 - pbinom(999, 6000, p = 1/6)
1 - pbinom(99, 6000, p = 1/6)
sum(dbinom(0:5, size = 300, p= 0.01))
sum(dbinom(0:5, size = 300, p= 0.50))
sum(dbinom(0:5, size = 300, p= 0.10))
sum(dbinom(0:3, size = 8, p= 0.50))
sum(dbinom(0:3, size = 8, p= 0.01))
sum(dbinom(0:3, size = 8, p= 0.1))
0.99^300
1 - sum(dbinom(0:5, size = 300, p= 0.01))
1 - sum(dbinom(0:4, size = 300, p= 0.01))
options(digits = 3)
1 - sum(dbinom(0:4, size = 300, p= 0.01))
###########################
####### Main #############
###########################
library(installr)
installr()
install.packages(c("BH", "broom", "callr", "car", "chron", "cli", "clipr", "coda", "colorspace", "conquer", "covr", "cowplot", "crayon", "crosstalk", "data.table", "DBI", "dbplyr", "deldir", "dendextend", "desc", "DescTools", "devtools", "diffobj", "digest", "doParallel", "doSNOW", "dplyr", "DT", "e1071", "effsize", "emmeans", "expm", "fansi", "farver", "fastmap", "fdrtool", "flexmix", "foghorn", "forcats", "foreach", "formattable", "Formula", "freetypeharfbuzz", "fs", "gargle", "gdtools", "GGally", "ggforce", "ggplot2", "ggraph", "ggrepel", "ggsignif", "ggthemes", "gh", "git2r", "glue", "gmp", "graphlayouts", "hexbin", "Hmisc", "hms", "htmlTable", "htmltools", "htmlwidgets", "httpuv", "httr", "hunspell", "igraph", "IRdisplay", "isoband", "iterators", "janitor", "jsonlite", "jtools", "labeling", "lavaan", "lifecycle", "lme4", "lmerTest", "lubridate", "magrittr", "maptools", "MASS", "matlib", "MatrixModels", "matrixStats", "memoise", "mime", "mnormt", "NLP", "openssl", "openxlsx", "partitions", "pbapply", "pbkrtest", "permutations", "pillar", "pkgbuild", "pkgdown", "pkgload", "plotly", "plotrix", "processx", "promises", "ps", "psych", "qdap", "qgraph", "quantreg", "R6", "rappdirs", "raster", "Rcpp", "RcppArmadillo", "RcppEigen", "RCurl", "readr", "remotes", "repr", "reprex", "rgdal", "rgeos", "rgl", "rio", "rlang", "rmarkdown", "ROI", "rprojroot", "rstatix", "rstudioapi", "rvest", "sf", "shiny", "shinytest", "slam", "sp", "SparseM", "spelling", "statmod", "statsr", "stringdist", "stringi", "sys", "systemfonts", "testthat", "tibble", "tidyr", "tm", "tweenr", "units", "usethis", "utf8", "vctrs", "vdiffr", "VGAM", "webdriver", "withr", "xlsx", "XML", "xmlparsedata", "zip"))
#clean environment
rm(list=ls())
#setwd to current folder
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#source other R-Files needed
source("packages.R")
#import data and make it a data.frame
X<-fread("..//data//train.csv")
X<-setDF(X)
class(X)
#set.seed
set.seed(1997)
# Inspection --------------------------------------------------------------
#general overview
names(X)
summary(X)
sapply(X, typeof)
glimpse(X)
dim(X) #103904, 25
#delete rows that are not of use.
X<-subset(X, select = -c(V1, id))
#check for balance of the criterion
table(X$satisfaction)
prop.table(table(X$satisfaction)) #No upsampling/downsampling required
#detect NAs
sapply(X, function(x) sum(is.null(x)))
sapply(X, function(x) sum(is.na(x))) #Arrival Delay in Minutes:310
#Is there a systematic relationship between NAs and criterion?
with(X, table(is.na(`Arrival Delay in Minutes`), satisfaction))[2,]
# 310 missing values - Are they all from the same flight?
onlyna<-X[which(is.na(X$`Arrival Delay in Minutes`)),]
max(table(onlyna$`Flight Distance`)) #No
#proportion of NAs in the dataset
with(X, prop.table(table(is.na(`Arrival Delay in Minutes`))))
#drop NA
X<-na.omit(X)
#delete variables which are no longer of use
rm(onlyna)
# Vizualisation -----------------------------------------------------------
#make barplots for ordinal and nominal variables
# for (i in c(1:2, 4:5, 7:20)) {
#   ggbarplot<-ggplot(X, aes(x = X[,i])) +
#     geom_bar() +
#     facet_wrap(~satisfaction) +
#     ggtitle(paste(names(X)[i])) +
#     xlab("") +
#     theme(axis.text.x = element_text(angle = 90))
#   ggsave(paste0("..//plots//plot",i,".jpg"),ggbarplot)
# }
#make histograms for intervall variables
# for (i in c(3, 6, 21:22)) {
#   gghistogram<-ggplot(X, aes(x = X[,i])) +
#     geom_histogram() +
#     facet_wrap(~satisfaction) +
#     ggtitle(paste(names(X)[i])) +
#     xlab("") +
#     theme(axis.text.x = element_text(angle = 90))
#   ggsave(paste0("..//plots//plot",i,".jpg"),gghistogram)
# }
#delete variables which are no longer of use
#rm(ggbarplot, gghistogram, i)
# Feature engineering -----------------------------------------------------
#make ordinal variables factors, which is easier to work with
for(i in 1:length(X)){
if(is.character(X[,i])){
X[,i]<-as.factor(X[,i])
}
}
glimpse(X)
#save the data with labels to a new dataframe
#(X will from now on be numeric)
Xlabels<-X
#Gender: 1 = Female; 2 = Male
levels(X$Gender)<-c(1:2)
#Customer Type: 1 = disloyal Customer; 2 = Loyal Customer
levels(X$`Customer Type`)<-c(1:2)
#Type of Travel: 1 = Business travel, 2 = Personal Travel
levels(X$`Type of Travel`)<-c(1:2)
#Class: 1 = Eco; 2 = Eco Plus; 3 = Business
levels(X$Class)<-c(3,1,2)
#satisfaction: 1 = neutral or dissatisfied; 2 = satisfied
levels(X$satisfaction)<-c(1:2)
# make factors to integers again
for(i in 1:length(X)){
if(is.factor(X[,i])){
X[,i]<-as.numeric(X[,i])
}
}
glimpse(X)
# Correlation -------------------------------------------------------------
#Variables where 0 doesn't mean "no answer"
table(X$`Flight Distance` == 0)
table(X$`Arrival Delay in Minutes` == 0)
table(X$`Departure Delay in Minutes` == 0)
#Make new dataframe which does not include 0s
Xnozero<-X
#Convert all 0 to NA; leave out last 3 columns (since 0 doesn't mean "no answer")
for (i in 1:(length(Xnozero)-3)) {
#if any value is zero, make it NA, else do nothing
Xnozero[,i]<-ifelse(Xnozero[,i] == 0, NA, Xnozero[,i])
}
#Calculate Spearman correlations from between the independent variables
#and the dependent variable (NAs are not used for correlation)
yxcorrelation<-list()
for(i in 1:(length(Xnozero)-1)){
yxcorrelation[[i]]<-data.table(y = "satisfaction",
x = names(Xnozero)[i],
cor = cor(y = Xnozero$satisfaction,
x = Xnozero[,i],
method = "spearman",
use = "complete.obs"))
}
#make list a data.table
yxcorrelation<-rbindlist(yxcorrelation)
#check correlation with cohens interpretation criteria
# correlations higher than 0.5
yxcorrelation[which(cor > 0.5 | cor < -0.5)]
# correlations between 0.3 and 0.5
yxcorrelation[which(cor > 0.3 & cor < 0.5 | cor < -0.3 & cor > -0.5)]
# correlations between 0.1 and 0.3
yxcorrelation[which(cor > 0.1 & cor < 0.3 | cor < -0.1 & cor > -0.3)]
# items not associated with criterion
yxcorrelation[which(cor < 0.1 & cor > -0.1)]
##Heatmap
#prepare correlationmatrix
cormat<-round(cor(Xnozero, method = "spearman", use = "complete.obs"),2)
cormat<-melt(cormat)
#Make heatmap
# ggheatmap<-ggplot(data = cormat,
#        aes(x = Var1,
#            y = Var2,
#            fill = value)) +
#   geom_tile(color = "white") +
#   scale_fill_gradient2(low = "black", #negative coefficients
#                        high = "black", #positive coefficients
#                        mid = "white", #coefficients close to 0
#                        midpoint = 0,
#                        limit = c(-1,1),
#                        name="Spearman \n Correlation") +
#   geom_text(aes(y = Var2,
#                 x = Var1,
#                 label = value),
#             color = "black",
#             size = 3) +
#   guides(fill = guide_colorbar(barwidth = 7,
#                                barheight = 1,
#                                title.position = "top",
#                                title.hjust = 0.1)) +
#   coord_fixed() +
#   geom_text(aes(y = Var2,
#                 x = Var1,
#                 label = value),
#             color = "black", size = 3) +
#   guides(fill = guide_colorbar(barwidth = 7,
#                                barheight = 1,
#                                title.position = "top",
#                                title.hjust = 0.1)) +
#   ylab("") +
#   xlab("") +
#   ggtitle("Heatmap to visualize all correlations of the dataset") +
#   theme(axis.text.x = element_text(angle = 45,
#                                    vjust = 1,
#                                    hjust = 1),
#         legend.position = "none")
#save heatmap to the plots folder
# ggsave("..//plots//heatmap.jpg",
#        width = 10.24,
#        height = 10.16,
#        ggheatmap)
#delete unnecessary items
rm(cormat, ggheatmap, yxcorrelation, i)
# Exploratory Factor Analysis ---------------------------------------------
library(FactoMineR)
library(factoextra)
factoranalysis<-FAMD(base = Xlabels[,-23],
ncp = 5,
graph = FALSE)
print(factoranalysis)
eigenvalues <- get_eigenvalue(factoranalysis)
eigenvalues
fviz_screeplot(factoranalysis)
# Plot of variables
fviz_famd_var(factoranalysis, repel = TRUE)
# Contribution to the first dimension
fviz_contrib(factoranalysis, "var", axes = 1)
# Contribution to the second dimension
fviz_contrib(factoranalysis, "var", axes = 2)
fviz_contrib(factoranalysis, "var", axes = 3)
fviz_famd_var(res.famd, "quanti.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
fviz_famd_var(factoranalysis, "quanti.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
fviz_famd_var(res.famd, "quali.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
fviz_famd_var(factoranalysis, "quali.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
#screeplot to decide how many dimensions will be needed
fviz_screeplot(factoranalysis)
# Contribution to the first dimension
fviz_contrib(factoranalysis, "var", axes = 1)
eigenvalues
print(factoranalysis)
factoranalysis$var
round(factoranalysis$var,3)
round(factoranalysis$var,3)
summary(factoranalysis)
x<-summary(factoranalysis)
eigenvalues
melt(eigenvalues)
#screeplot to decide how many dimensions will be needed
fviz_screeplot(factoranalysis)
# Plot of variables
fviz_famd_var(factoranalysis, repel = TRUE)
# Contribution to the first 4 dimensions
fviz_contrib(factoranalysis, "var", axes = 1)
fviz_contrib(factoranalysis, "var", axes = 2)
fviz_contrib(factoranalysis, "var", axes = 3)
fviz_contrib(factoranalysis, "var", axes = 4)
fviz_contrib(factoranalysis, "var", axes = 5)
fviz_famd_var(factoranalysis, "quanti.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
fviz_famd_var(factoranalysis, "quali.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
#screeplot
fviz_screeplot(factoranalysis)
get_eigenvalue(factoranalysis)
# Plot the first two dimensions
fviz_famd_var(factoranalysis, repel = TRUE)
get_eigenvalue(factoranalysis) %>% kable()
#screeplot
fviz_screeplot(factoranalysis)
# Plot the first two dimensions
fviz_famd_var(factoranalysis, repel = TRUE)
fviz_contrib(factoranalysis, "var", axes = 1)
fviz_contrib(factoranalysis, "var", axes = 2)
fviz_contrib(factoranalysis, "var", axes = 3)
fviz_contrib(factoranalysis, "var", axes = 4)
fviz_contrib(factoranalysis, "var", axes = 5)
#Plot of the quantitative variables
fviz_famd_var(factoranalysis, "quanti.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE)
#Plot of the qualitative variables
fviz_famd_var(factoranalysis, "quali.var", col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
